% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/get.distances.R
\name{get.distances}
\alias{get.distances}
\title{Find distances between nearby points, just searching within a specified maximum distance.}
\usage{
get.distances(frompoints, topoints, max.miles = 5, max.km = 8.0467,
  return.units = "miles", return.rownums = TRUE, return.latlons = FALSE,
  return.crosstab = FALSE, tailored.deltalon = TRUE)
}
\arguments{
\item{frompoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{topoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{max.miles}{A single number defining nearby, the maximum distance searched for or recorded. Default is 5 miles unless max.km specified.}

\item{max.km}{A single number defining nearby, the maximum distance searched for or recorded. Default is 8.0467 kilometers unless max.miles specified.}

\item{return.units}{A string that is 'miles' by default, or 'km' for kilometers, specifying units for distances returned.}

\item{return.rownums}{Logical value, TRUE by default. If TRUE, value returned also includes two extra columns:
a col of index numbers starting at 1 specifying the frompoint and a similar col specifying the topoint.}

\item{return.latlons}{Logical value, FALSE by default. If TRUE, value returned also includes four extra columns,
showing fromlat, fromlon, tolat, tolon.}

\item{return.crosstab}{Logical value, FALSE by default. If TRUE, value returned is a matrix of the distances,
with a row per frompoint and col per topoint. (Distances larger than max search radius are not provided, even in this format).}

\item{tailored.deltalon}{Logical value, TRUE by default. Defines size of initially searched area as function of lat, for each frompoint,
rather than initially searching a conservatively large box. The large box is big enough for even the Northernmost US (AK) but perhaps not for further north!
Taking time to scale the box according to latitude makes it work for anywhere in the N. Hemisphere (Southern not tested),
and speeds up the distance calculations closer to the equator, but takes a bit of time to define a custom box for each frompoint
so it might be slower overall in just very northern locations? Comprehensive speed tests have not been performed.}
}
\value{
By default, returns a matrix that has 3 columns: fromrow, torow, distance (where fromrow or torow is the row number of the corresponding input, starting at 1).
  Distance returned is in miles by default, but with option to set return.units='km' to get kilometers.
  See parameters for details on other formats that may be returned if specified.
}
\description{
\code{get.distances} returns the distances from one set of points to nearby members of another set of points.
}
\details{
This function returns a matrix or vector of distances,
which are the distances from one set of points to the nearby members of another set of points.
It searches within a circle (of radius max.miles or max.km, defining what is considered nearby),
to calculate distance (in miles or km) from each of frompoints to each of topoints that is within the specified radius.
Points are specified using latitude and longitude in decimal degrees.
Relies on the sp package for the spDists() and SpatialPoints() functions.
Uses get.distances.all() but for performance it only uses it for distance pairs (pairs of points) that have been initially
quickly filtered using lat/lon to be not much more than max.km or max.miles, in an attempt to go
much faster than finding every distance pair and then dropping all outside the search radius.
Finding distance to all of the 11 million census blocks in usa within 5 km, for 100 points, can take a while... maybe >1 minute?
May wish to investigate using data.table to index and more quickly subset the (potentially 11 million Census blocks of) topoints
(or pre-index that block point dataset and allow this function to accept a data.table as input).
}
\examples{
test.from <- structure(list(fromlat = c(38.9567309094, 38.9507043428),
    fromlon = c(-77.0896572305, -77.0896199948)),
    .Names = c("lat", "lon"), row.names = c("6054762", "6054764"), class = "data.frame")
    test.to <- structure(list(tolat = c(38.9575019287, 38.9507043428, 38.9514152435),
    tolon = c(-77.0892818598, -77.0896199948, -77.0972395245)),
    .Names = c("lat", "lon"), class = "data.frame",
    row.names = c("6054762", "6054763", "6054764"))

    n=100
    test.from2 <- structure(list(fromlat = runif(n, min=25,max=48),
     fromlon = runif(n,min=-125,max=-70) ),
     .Names = c("lat", "lon"), row.names = 1:n, class = "data.frame")
    n=1000
    test.to2 <- structure(list(tolat = runif(n, min=25,max=48),
     tolon = runif(n,min=-125,max=-70) ),
     .Names = c("lat", "lon"), row.names = 1:n, class = "data.frame")

    # see as map of many points
    #*** Can fail if max.miles=50... Error in rbind() numbers of
    #  columns of arguments do not match !
    #big = get.distances(test.from2, test.to2, max.miles=100, return.latlons=TRUE)
    big = get.distances(test.from2, test.to2, max.miles=100, return.latlons=TRUE)
    plot(big$fromlon, big$fromlat,main='from black circles...
     closest is red, others nearby are green ')
    points(test.to2$lon, test.to2$lat, col='blue',pch='.')
    points(big$tolon, big$tolat, col='green')
    junk=as.data.frame( get.nearest(test.from2, test.to2) )
    points(test.to2$lon[junk$n],test.to2$lat[junk$n],col='red')

    # test cases

get.distances(test.from[1,],test.to[1,],max.miles=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1,],test.to[1,],max.miles=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1,],test.to[1,],max.miles=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1,],test.to[1,],max.miles=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1,],test.to[1:3,],max.miles=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1,],test.to[1:3,],max.miles=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1,],test.to[1:3,],max.miles=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1,],test.to[1:3,],max.miles=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1:2,],test.to[1,],max.miles=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1,],max.miles=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1,],max.miles=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1,],max.miles=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1:2,],test.to[1:3,],max.miles=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1:3,],max.miles=999,return.rownums=FALSE,
return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1:3,],max.miles=999,return.rownums=TRUE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1:3,],max.miles=999,return.rownums=TRUE,
return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1:3,],max.km=0.7,  return.rownums=TRUE,
return.latlons=TRUE)

get.distances(test.from[1,],test.to[1:3, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1:3, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1:3, ], max.km=0.7, return.crosstab=TRUE)
  # Warning message:
  # In get.distances(test.from[1:2, ], test.to[1:3, ], max.km = 0.7,  :
  # Ignoring return.crosstab because max.miles was specified
}
\seealso{
\code{\link{get.distances.all}} for get.distances.all() which allows you to get distances between all points,
  \code{\link{get.distances.prepaired}} for finding distances when data are already formatted as pairs of points,
  \code{\link{get.nearest}} for get.nearest() which finds the distance to the single nearest point
  within a specified search radius instead of all topoints, and
  \code{\link{proxistat}} which calculates a proximity score for each spatial unit based on distances to nearby points.
}
\concept{
proximity
}


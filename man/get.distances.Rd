% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/get.distances.R
\name{get.distances}
\alias{get.distances}
\title{Find distances between nearby points, just searching within a specified maximum distance.}
\usage{
get.distances(frompoints, topoints, radius = 5, units = "miles",
  ignore0 = FALSE, return.rownums = TRUE, return.latlons = FALSE,
  return.crosstab = FALSE, tailored.deltalon = TRUE)
}
\arguments{
\item{frompoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{topoints}{A matrix or data.frame with two cols, 'lat' and 'lon' with datum=WGS84 assumed.}

\item{radius}{A single number defining nearby, the maximum distance searched for or recorded. Default is 5 miles, which is 8.0467 km, unless units or radius is specified.}

\item{units}{A string that is 'miles' by default, or 'km' for kilometers, specifying units for radius and distances returned.}

\item{ignore0}{A logical, default is FALSE, specifying whether to ignore distances that are zero and report only nonzero distances.
Useful if want distance to points other than self, where frompoints=topoints, for example. Ignored if return.crosstab = TRUE.}

\item{return.rownums}{Logical value, TRUE by default. If TRUE, value returned also includes two extra columns:
a col of index numbers starting at 1 specifying the frompoint and a similar col specifying the topoint.}

\item{return.latlons}{Logical value, FALSE by default. If TRUE, value returned also includes four extra columns,
showing fromlat, fromlon, tolat, tolon.}

\item{return.crosstab}{Logical value, FALSE by default. If TRUE, value returned is a matrix of the distances,
with a row per frompoint and col per topoint. (Distances larger than max search radius are not provided, even in this format).}

\item{tailored.deltalon}{Logical value, TRUE by default. Defines size of initially searched area as function of lat, for each frompoint,
rather than initially searching a conservatively large box. The large box is big enough for even the Northernmost US (AK) but perhaps not for further north!
Taking time to scale the box according to latitude makes it work for anywhere in the N. Hemisphere (Southern not tested),
and speeds up the distance calculations closer to the equator, but takes a bit of time to define a custom box for each frompoint
so it might be slower overall in just very northern locations? Comprehensive speed tests have not been performed.

Just using get.distances.all is reasonably fast (30-40 seconds for 100 million distances, but slow working with results so large),
  and could remove those outside the radius after that, skipping the searchbox approach:

Sys.time(); x=get.distances.all(testpoints(1e5), testpoints(1000), return.crosstab=TRUE); Sys.time()
[1] "2015-03-10 18:59:08 EDT"
[1] "2015-03-10 18:59:31 EDT"  23 SECONDS  for 100 million distances IF NO PROCESSING OTHER THAN CROSSTAB
Sys.time(); x=get.distances.all(testpoints(1e6), testpoints(100), return.crosstab=TRUE); Sys.time()
[1] "2015-03-10 21:54:11 EDT"
[1] "2015-03-10 21:54:34 EDT"  23 SECONDS for 100 million distances (1m x 100, or 100k x 1000)
Sys.time(); x=get.distances.all(testpoints(1e6), testpoints(300), return.crosstab=TRUE); Sys.time()
[1] "2015-03-10 21:56:11 EDT"
[1] "2015-03-10 21:57:18 EDT"  67 seconds for 300 million pairs.

           #' so 11m blocks to 1k points could take >40 minutes!
           >3 minutes per 100 sites?
           About 2.6 seconds per site for 11m blocks?

> Sys.time(); x=get.distances.all(testpoints(1e5), testpoints(1000), units='miles',return.rownums=TRUE); Sys.time()
[1] "2015-03-09 21:23:04 EDT"
[1] "2015-03-09 21:23:40 EDT"  36 SECONDS IF DATA.FRAME ETC. DONE TO FORMAT RESULTS AND GET ROWNUMS
> Sys.time(); x=get.distances.all(testpoints(1e5), testpoints(1000), units='miles',return.rownums=TRUE)$d; Sys.time()
[1] "2015-03-09 21:18:47 EDT"
[1] "2015-03-09 21:19:26 EDT" 49 SECONDS IF DATA.FRAME ETC. DONE TO FORMAT RESULTS AND GET ROWNUMS IN get.distances.all

get.distances using loop and searchbox is Too slow:

On a quadcore i7 MacBookPro10,1 2012 with 16GB RAM, it takes 2.5 minutes for 100k frompoints (like block groups not blocks) to 1k sites/topoints.
> Sys.time(); x=get.distances(testpoints(1e5), testpoints(1000), units='miles',radius=5,return.rownums=TRUE)$d; Sys.time()
[1] "2015-03-09 21:13:08 EDT"
[1] "2015-03-09 21:15:40 EDT"  152 SECONDS IF USE SEARCH BOX & THEN RADIUS ****
> Sys.time(); x=get.distances(testpoints(1e5), testpoints(100), units='miles',radius=5,return.rownums=TRUE)$d; Sys.time()
[1] "2015-03-09 21:11:55 EDT"
[1] "2015-03-09 21:12:24 EDT"  29 SEC FOR SMALLER JOB
> Sys.time(); x=get.distances(testpoints(1e4), testpoints(1000), units='miles',radius=5,return.rownums=TRUE)$d; Sys.time()
[1] "2015-03-09 21:12:40 EDT"
[1] "2015-03-09 21:12:53 EDT" 13 SEC FOR SMALLER JOB of frompoints but same total points}
}
\value{
By default, returns a dataframe that has 3 columns: fromrow, torow, distance (where fromrow or torow is the row number of the corresponding input, starting at 1).
  Distance returned is in miles by default, but with option to set units='km' to get kilometers.
  See parameters for details on other formats that may be returned if specified.
}
\description{
\code{get.distances} returns the distances from one set of points to nearby members of another set of points.
}
\details{
This function returns a matrix or vector of distances,
which are the distances from one set of points to the nearby members of another set of points.
It searches within a circle (of radius = radius, defining what is considered nearby),
to calculate distance (in miles or km) from each of frompoints to each of topoints that is within the specified radius.
Points are specified using latitude and longitude in decimal degrees.
#' \cr\cr
Relies on the \pkg{sp} package for the \code{\link[sp]{spDists}} and \code{\link[sp]{SpatialPoints}} functions.
Uses \code{\link{get.distances.all}} but for performance it only uses it for distance pairs (pairs of points) that have been initially
quickly filtered using lat/lon to be not much more than radius, in an attempt to go
much faster than finding every distance pair and then dropping all outside the search radius.
\cr\cr
Finding distance to all of the 11 million census blocks in usa within 5 km, for 100 points, can take a while... maybe >1 minute?
May need to switch to just use a js library like turf, or investigate using data.table to index and more quickly subset the (potentially 11 million Census blocks of) topoints
(or pre-index that block point dataset and allow this function to accept a data.table as input).
}
\examples{
#
   test.from <- structure(list(fromlat = c(38.9567309094, 45),
     fromlon = c(-77.0896572305, -100)), .Names = c("lat", "lon"),
     row.names = c("1", "2"), class = "data.frame")

   test.to <- structure(list(tolat = c(38.9575019287, 38.9507043428, 45),
    tolon = c(-77.0892818598, -77.2, -90)),
    .Names = c("lat", "lon"), class = "data.frame",
    row.names = c("1", "2", "3"))

   testpoints <- function(n) {
     structure(list(tolat = runif(n, min=40,max=42), tolon = runif(n,min=-125,max=-70) ),
     .Names = c("lat", "lon"), row.names = 1:n, class = "data.frame")
   }

   n=100
   test.from2 <- testpoints(n)
   n=1000
   test.to2 <- testpoints(n)

   # see as map of many points
   #*** Can fail if radius=50 miles? ... Error in rbind() numbers of
   #  columns of arguments do not match !
   #big = get.distances(test.from2, test.to2, radius=100, units='miles', return.latlons=TRUE)
   big = get.distances(test.from2, test.to2, radius=100, units='miles', return.latlons=TRUE)
   plot(big$fromlon, big$fromlat,main='from black circles...
     closest is red, others nearby are green ')
   points(test.to2$lon, test.to2$lat, col='blue',pch='.')
   points(big$tolon, big$tolat, col='green')
   junk=as.data.frame( get.nearest(test.from2, test.to2) )
   points(test.to2$lon[junk$n],test.to2$lat[junk$n],col='red')

    # test cases

get.distances(test.from[1,],test.to[1,],radius=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1,],test.to[1,],radius=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1,],test.to[1,],radius=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1,],test.to[1,],radius=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1,],test.to[1:3,],radius=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1,],test.to[1:3,],radius=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1,],test.to[1:3,],radius=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1,],test.to[1:3,],radius=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1:2,],test.to[1,],radius=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1,],radius=999,return.rownums=FALSE,return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1,],radius=999,return.rownums=TRUE,return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1,],radius=999,return.rownums=TRUE,return.latlons=TRUE)

get.distances(test.from[1:2,],test.to[1:3,],radius=999,return.rownums=FALSE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1:3,],radius=999,return.rownums=FALSE,
return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1:3,],radius=999,return.rownums=TRUE,
return.latlons=FALSE)
get.distances(test.from[1:2,],test.to[1:3,],radius=999,return.rownums=TRUE,
return.latlons=TRUE)
get.distances(test.from[1:2,],test.to[1:3,], radius=0.7,return.rownums=TRUE,
return.latlons=TRUE, units='km')
get.distances(test.from[1:2,],test.to[1:3,], radius=0.7,return.rownums=TRUE,
return.latlons=TRUE, units='miles')

get.distances(test.from[1,],test.to[1:3, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1:3, ], return.crosstab=TRUE)
get.distances(test.from[1:2,],test.to[1:3, ], radius=0.7, return.crosstab=TRUE)
  # Warning message:
  # In get.distances(test.from[1:2, ], test.to[1:3, ], radius = 0.7,  :
  # Ignoring return.crosstab because radius was specified
}
\seealso{
\code{\link{get.distances.all}} which allows you to get distances between all points,
  \code{\link{get.distances.prepaired}} for finding distances when data are already formatted as pairs of points,
  \code{\link{get.nearest}} which finds the distance to the single nearest point
  within a specified search radius instead of all topoints, and
  \code{\link{proxistat}} which calculates a proximity score for each spatial unit based on distances to nearby points.
}
\concept{
proximity
}

